<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [概述](#概述)
- [基础知识](#基础知识)
    - [变量](#变量)
      - [系统预定义变量](#系统预定义变量)
      - [自定义变量](#自定义变量)
      - [特殊变量](#特殊变量)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

写在前面：此笔记来自b站课程[3天搞定Linux，1天搞定Shell](https://www.bilibili.com/video/BV1WY4y1H7d3) P66-P
### 概述
shell是外层应用程序与系统内核连接的桥梁，本质上一个命令行解释器——它接收应用程序/用户的命令，然后调用操作系统内核
**基本格式**：
- 注释以`#`开头
- 脚本第一行指定解析器`#!/bin/bash`
- 之后的就是shell代码

**执行方式**：
- bash/sh+脚本的绝对/相对路径
    ![概述1](./md-image/概述1.png){:width=80 height=80}
- 直接输入脚本的绝对/相对路径，但要为脚本添加可执行权限`chmod +x 脚本路径`
    ![概述2](./md-image/概述2.png){:width=120 height=120}
    可以看到文件名变成绿色，代表可被执行
    注：使用相对路径时不能直接写`test.sh`，必须写成`./test.sh`。因为系统会将`test.sh`当成命令（在/bin目录中寻找同名文件）去执行

为什么第一种方式不需可执行权限：第一种实际上是运行`sh`或`bash`命令，脚本路径作为参数；而第二种是将脚本名作为命令
**补充：使用`.`或`source`命令也可执行脚本文件**
![概述3](./md-image/概述3.png){:width=80 height=80}
区别：前两种都是再开一个**子shell**进程去执行脚本，而`.`和`source`是直接在当前shell环境中执行。有时候子shell会出现内外层环境变量不通用的问题，这时就需要`.`和`source`来执行，例如有时更改了某个配置文件，为使其立即生效，就运行`source .profile`命令

---

**补充：能不能通过直接输入脚本名称的方式来运行脚本？**
其实是可以的，因为系统会在`/bin`中找命令/脚本文件，所以如果该文件位于`/bin`目录下，就可以这样执行。但一般情况下，不推荐改变`/bin`目录中的文件
方法：更改`$PATH`变量，相当于Windows环境变量中的path
### 基础知识
##### 变量
主要分为系统定义的和用户定义的变量，还可分为全局变量和局部变量
- 全局变量是当前bash进程和其子进程都可访问
- 局部变量只在当前bash进程中可访问，其子进程无法访问

使用`set`/`set | less`命令查看当前环境内的全部变量
###### 系统预定义变量
可以理解成环境变量，通常是全局的
- `HOME`主目录路径
- `PWD`当前工作目录
- `SHELL`当前使用的shell解释器
- `USER`当前用户
- 还有很多类似的，都是由大写字母组成的

```sh
echo $HOME  # 查看某个系统变量
printenv HOME  # 查看某个系统变量，不需要加$符号
env  # 查看全部系统变量
env | less  # 更清楚地查看
printenv
printenv | less  # 同上，也是查看全部系统变量
```
`printenv`只是单纯查看变量值，所以不加`$`，正常情况下我们想使用变量，都要在变量名加`$`，例如
```sh
ls $HOME  # 查看主目录内容
```
###### 自定义变量
- **定义/更改变量**：`变量名=变量值`，注意`=`**前后不能有空格**，因为加了空格之后bash会将空格前的内容当成命令
- **删除变量**：`unset 变量名`
- **声明只读变量**：`readonly 变量名=变量值`，它不能被修改/删除

**变量定义规则**：
- 变量名可由字母、数字、下划线组成，不能以数字开头
- 环境变量名建议大写
- 变量默认类型都是字符串类型，不能直接进行数值运算
- 变量值如果有空格，需用单/双引号括起来；如果没空格，可以不加引号直接写（反之默认都是字符串）

**补充**：
- 使用`echo $变量名`输出变量值
- 如果一个变量名没有声明/赋值，也可以用上述方法输出，只是结果为空行，不会报错

**注意**：
- 使用`变量名=变量值`创建的都是局部变量，如果希望其提升为全局变量，可以使用`export 变量名`，这样它就可以在子shell中使用。但如果在子shell中对该变量重新赋值，只有子shell中的这个变量发生改变，外层的该变量不变（即使在子shell中使用export也不行）
- 如果我们在命令行中声明了局部变量，现在运行一个shell脚本，其中用到了上述局部变量
  - 使用`.`/`source`运行，可以访问到，因为它们都是在当前进程中运行的
  - 使用`sh`/`bash`/路径运行，不能访问，因为它们是在子shell中运行，子shell不能访问父级的局部变量
    
  解决方法：使用export提升父级变量

![变量1](./md-image/变量1.png){:width=150 height=150}
![变量4](./md-image/变量4.png){:width=200 height=200}
![变量2](./md-image/变量2.png){:width=400 height=400}
其中`bash`命令可以打开一个子shell，`ps -f`检查是否在子shell中（如果由两个bash就是在子shell）
创建`test.sh`：
```sh
#!/bin/bash
echo $my_var
```
![变量3](./md-image/变量3.png){:width=150 height=150}

###### 特殊变量
注：所有的特殊变量只有在**双引号**中或者**不加引号**才会被认为是变量，在单引号中会被认为是普通字符串
- `$n`：n为数字，表示在命令行中执行该脚本时后面跟着的参数——`$0`代表该脚本名称（命令行中执行的文件名称），`$1`-`$9`代表第1-9个参数，如果n>=10，需用大括号包含，如`${10}`
- `$#`获取所有输入的参数个数（不包括脚本名称`$0`），常配合循环使用，配合参数的个数是否正确
    ```sh
    #!/bin/bash
    echo '-------------$n----------------'
    echo "I'm $0"
    echo "Hello, $1"
    echo '-------------$#----------------'
    echo parameter numbers: $#
    ```
    ![变量5](./md-image/变量5.png){:width=250 height=250}
- `$*`获取所有参数（把所有的参数都看成一个整体）
- `$@`获取所有参数构成的集合（把每个参数区分对待）
    注：如果不使用循环遍历，上面得到的结果其实是一样的
    ```sh
    #!/bin/bash
    echo '-------------$*----------------'
    echo $*
    echo '-------------$@----------------'
    echo $@
    ```
    ![变量6](./md-image/变量6.png){:width=100 height=100}
- `$?`获取上一次执行的命令的返回状态。如果其值为0，则上个命令正确执行；如果非0，则说明执行出错（具体是哪个值由上个命令自己决定）
    ![变量7](./md-image/变量7.png){:width=220 height=220}
