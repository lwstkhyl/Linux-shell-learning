<a id="mulu">目录</a>
<a href="#mulu" class="back">回到目录</a>
<style>
    .back{width:40px;height:40px;display:inline-block;line-height:20px;font-size:20px;background-color:lightyellow;position: fixed;bottom:50px;right:50px;z-index:999;border:2px solid pink;opacity:0.3;transition:all 0.3s;color:green;}
    .back:hover{color:red;opacity:1}
    img{vertical-align:bottom;}
</style>

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [概述](#概述)

<!-- /code_chunk_output -->

<!-- 打开侧边预览：f1->Markdown Preview Enhanced: open...
只有打开侧边预览时保存才自动更新目录 -->

写在前面：此笔记来自b站课程[3天搞定Linux，1天搞定Shell](https://www.bilibili.com/video/BV1WY4y1H7d3) P66-P
### 概述
shell是外层应用程序与系统内核连接的桥梁，本质上一个命令行解释器——它接收应用程序/用户的命令，然后调用操作系统内核
**基本格式**：
- 注释以`#`开头
- 脚本第一行指定解析器`#!/bin/bash`
- 之后的就是shell代码

**执行方式**：
- bash/sh+脚本的绝对/相对路径
    ![概述1](./md-image/概述1.png){:width=80 height=80}
- 直接输入脚本的绝对/相对路径，但要为脚本添加可执行权限`chmod +x 脚本路径`
    ![概述2](./md-image/概述2.png){:width=120 height=120}
    可以看到文件名变成绿色，代表可被执行
    注：使用相对路径时不能直接写`test.sh`，必须写成`./test.sh`。因为系统会将`test.sh`当成命令（在/bin目录中寻找同名文件）去执行

为什么第一种方式不需可执行权限：第一种实际上是运行`sh`或`bash`命令，脚本路径作为参数；而第二种是将脚本名作为命令
**补充：使用`.`或`source`命令也可执行脚本文件**
![概述3](./md-image/概述3.png){:width=80 height=80}
区别：前两种都是再开一个**子shell**进程去执行脚本，而`.`和`source`是直接在当前shell环境中执行。有时候子shell会出现内外层环境变量不通用的问题，这时就需要`.`和`source`来执行，例如有时更改了某个配置文件，为使其立即生效，就运行`source .profile`命令